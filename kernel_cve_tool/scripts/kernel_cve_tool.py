import argparse
import logging as log
import os
import json
import sys
import re
import subprocess


def load_cvedata(dbpath: str) -> (dict, dict, dict):
    with open(os.path.join(dbpath, 'data', 'kernel_cves.json'), 'r', encoding='UTF-8') as f:
        kernel_cves = json.load(f)
    with open(os.path.join(dbpath, 'data', 'stream_data.json'), 'r', encoding='UTF-8') as f:
        stream_data = json.load(f)
    with open(os.path.join(dbpath, 'data', 'stream_fixes.json'), 'r', encoding='UTF-8') as f:
        stream_fixes = json.load(f)
    return kernel_cves, stream_data, stream_fixes


def extract_version() -> (int, int, int):
    version = patchlevel = sublevel = None
    verpat = re.compile(r'VERSION\s*=\s*([0-9]+)')
    plpat = re.compile(r'PATCHLEVEL\s*=\s*([0-9]+)')
    subpat = re.compile(r'SUBLEVEL\s*=\s*([0-9]+)')
    with open('Makefile', 'r', encoding='UTF-8') as f:
        for line in f:
            if version and patchlevel and sublevel:
                break
            m = re.match(verpat, line)
            if m is not None:
                version = int(m.group(1))
                continue
            m = re.match(plpat, line)
            if m is not None:
                patchlevel = int(m.group(1))
                continue
            m = re.match(subpat, line)
            if m is not None:
                sublevel = int(m.group(1))
    return version, patchlevel, sublevel


def runcmd(cmd) -> (bool, str):
    try:
        proc = subprocess.run(cmd, stdin=subprocess.DEVNULL,
                              capture_output=True, encoding='UTF-8')
        return True, proc.stdout
    except subprocess.CalledProcessError:
        return False, None


def find_highest_tag(ver: int, pl: int) -> int:
    ok, output = runcmd(['git', 'tag', '-l', 'v{}.{}.*'.format(ver, pl)])
    if not ok:
        log.error("Could not locate tags for v{}.{}".format(ver, pl))
        return 999
    tags = output.rstrip().split('\n')
    highest = 0
    for tag in tags:
        sublevel = int(tag.split('.')[2])
        if sublevel > highest:
            highest = sublevel
    return highest


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('-P', '--database-path', help='path to CVE database repository', required=True)
    parser.add_argument('-d', '--debug', help='print debug messages', action='store_true')
    args = parser.parse_args()
    log.basicConfig(format="%(message)s", level=log.DEBUG if args.debug else log.INFO)
    ok, output = runcmd(['git', 'symbolic-ref', '--short', 'HEAD'])
    if not ok:
        log.error("Cannot get current branch")
        return 1
    branch = output.split('\n')[0]
    log.info("Current branch: {}".format(branch))
    kernel_cves, stream_data, stream_fixes = load_cvedata(args.database_path)
    ver, pl, sub = extract_version()
    stream = stream_data["{}.{}".format(ver, pl)]
    fixed = set()
    for i in range(1, sub + 1):
        try:
            fixed.update(list(stream["{}.{}.{}".format(ver, pl, i)].keys()))
        except KeyError:
            pass
    unfixed = set(list(stream["outstanding"].keys()))
    maxsub = find_highest_tag(ver, pl)
    log.info("Locating CVE patches for v{}.{}.{} through v{}.{}.{}".format(ver, pl, sub + 1, ver, pl, maxsub))
    verbase = "{}.{}".format(ver, pl)
    for i in range(sub + 1, maxsub + 1):
        try:
            unfixed.update(list(stream[verbase + "." + str(i)]))
        except KeyError:
            pass
    log.debug("Fixed({}): {}".format(len(fixed), ','.join(sorted(fixed))))
    log.debug("Unfixed({}): {}".format(len(unfixed), ','.join(sorted(unfixed))))
    both = fixed & unfixed
    if len(both) > 0:
        print("Found in both fixed and unfixed: {}".format(','.join(sorted(both))))
    found = set()
    cherrypicks = dict()
    cphashes = dict()
    riskier_cphashes = dict()
    skipped = set()
    for cve in unfixed:
        try:
            cmt = stream_fixes[cve][verbase]['cmt_id']
            for_this_version = True
        except KeyError:
            log.info("No commit for {} in {}".format(cve, verbase))
            cmt = kernel_cves[cve]['fixes']
            for_this_version = False
            if cmt == "" or cmt == "-":
                log.info("No commit anywhere for {}, skipping".format(cve))
                skipped.update([cve])
                continue
        ok, output = runcmd(['git', 'log', '-n', '1', '--pretty=%s', cmt])
        if not ok:
            log.warning("Could not find commit {} for {}".format(cmt, cve))
            continue
        subject = output.split('\n')[0]
        if len(subject) == 0:
            log.warning("Null commit subject for hash {} for {}".format(cmt, cve))
            continue
        cmd = ['git', 'log', '-n', '1', '--grep={}'.format(cmt),
               '--grep={}'.format(subject), '--grep={}'.format(cve)]
        if for_this_version:
            master_cmt = kernel_cves[cve]['fixes']
            if master_cmt and master_cmt != cmt:
                cmd.append('--grep={}'.format(master_cmt))
        cmd.append('v{}...HEAD'.format(verbase))
        ok, output = runcmd(cmd)

        if ok and len(output) > 0:
            localhash = output.split('\n')[0].split()[1]
            log.info("Branch has commit {} for {}".format(localhash, cve))
            found.update([cve])
        else:
            cherrypicks[cve] = hash
            if cmt in cphashes:
                cphashes[cmt].update([cve])
            elif cmt in riskier_cphashes:
                riskier_cphashes[cmt].update([cve])
            elif for_this_version:
                cphashes[cmt] = {cve}
            else:
                riskier_cphashes[cmt] = {cve}
    fixed |= found
    unfixed -= found
    log.debug("Fixed({}): {}".format(len(fixed), ','.join(sorted(fixed))))
    log.debug("Unfixed({}): {}".format(len(unfixed), ','.join(sorted(unfixed))))
    log.debug("No fixes({}): {}".format(len(skipped), ','.join(sorted(skipped))))
    with open("PATCHED-CVES", "w", encoding="UTF-8") as f:
        f.write('\n'.join(sorted(list(fixed))) + '\n')
    with open("cherry-picks.list", "w", encoding="UTF-8") as f:
        for cmt in cphashes:
            print("{}:{}".format(cmt, ' '.join(sorted(list(cphashes[cmt])))), file=f)
        for cmt in riskier_cphashes:
            print("{}:{} (NOT FOR THIS VERSION)".format(cmt, ' '.join(sorted(list(riskier_cphashes[cmt])))), file=f)
    with open("NO-FIXES-AVAILABLE", "w", encoding="UTF-8") as f:
        f.write('\n'.join(sorted(list(skipped))) + '\n')
    return 0


if __name__ == "__main__":
    # noinspection PyBroadException
    try:
        ret = main()
        sys.exit(ret)
    except SystemExit:
        pass
    except Exception:
        import traceback

        traceback.print_exc(5)
        sys.exit(1)
